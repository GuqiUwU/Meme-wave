<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MemeWave - made by Giu Giu</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom styles if needed beyond Tailwind */
  </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen">
  <div id="root"></div>
  <script type="text/babel">
    // MemeWave â€” single-file React front-end (standalone HTML version)
    // Dark theme, 2 pages: Feed / Game
    // Integrates multiple overseas + domestic sources with automatic fallback & retry logic.
    // Added: Time filter (All, Today, Week, Month) â€” client-side based on meme dates where available.
    // NOTE: This is still a front-end-only demo. CORS and API keys may be required for some sources.
    // Usage: Open index.html in browser (use dev proxy for CORS if needed).

    const { useEffect, useState, useRef, useMemo } = React;

    function MemeWaveApp() {
      const [route, setRoute] = useState("feed");
      const [foreignFeed, setForeignFeed] = useState([]);
      const [domesticFeed, setDomesticFeed] = useState([]);
      const [loading, setLoading] = useState(false);
      const [activeTab, setActiveTab] = useState("foreign");
      const [timeFilter, setTimeFilter] = useState("all");
      const [error, setError] = useState(null);

      useEffect(() => {
        loadFeeds();
      }, []);

      async function loadFeeds() {
        setLoading(true);
        setError(null);
        try {
          const fImgs = await tryFetchForeignImages();
          const dImgs = await tryFetchDomesticImages();
          // ensure results are arrays of {id, title, url, source, date?}
          setForeignFeed(shuffleArray(fImgs).slice(0, 80));
          setDomesticFeed(shuffleArray(dImgs).slice(0, 80));
        } catch (e) {
          console.error(e);
          setError("åŠ è½½éƒ¨åˆ†æ¢—å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚å¯èƒ½æ˜¯ CORS æˆ–æ¥å£éœ€è¦ API Keyã€‚");
        } finally {
          setLoading(false);
        }
      }

      const currentFeed = activeTab === "foreign" ? foreignFeed : domesticFeed;

      const filteredFeed = useMemo(() => {
        const now = new Date();
        return currentFeed.filter((m) => {
          if (timeFilter === "all" || !m.date) return true;
          const mDate = new Date(m.date);
          switch (timeFilter) {
            case "today":
              return mDate.toDateString() === now.toDateString();
            case "week":
              return mDate > new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            case "month":
              return mDate > new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            default:
              return true;
          }
        });
      }, [currentFeed, timeFilter]);

      return (
        <div className="min-h-screen bg-gray-900 text-gray-100 font-sans">
          <header className="p-4 flex items-center justify-between border-b border-gray-800">
            <h1 className="text-2xl font-bold tracking-tight">MemeWave</h1>
            <nav className="flex items-center gap-2">
              <button onClick={() => setRoute("feed")} className={`px-3 py-1 rounded-md ${route === "feed" ? "bg-gray-800" : "bg-transparent"}`}>
                çƒ­æ¢—å¢™
              </button>
              <button onClick={() => setRoute("game")} className={`px-3 py-1 rounded-md ${route === "game" ? "bg-gray-800" : "bg-transparent"}`}>
                å°æ¸¸æˆ
              </button>
              <button onClick={loadFeeds} className="px-3 py-1 rounded-md bg-gray-800 ml-2">åˆ·æ–°æ¢—</button>
            </nav>
          </header>
          <main className="p-6">
            {route === "feed" ? (
              <FeedPage
                loading={loading}
                error={error}
                filteredFeed={filteredFeed}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
                timeFilter={timeFilter}
                setTimeFilter={setTimeFilter}
              />
            ) : (
              <GamePage feedImages={filteredFeed} onBack={() => setRoute("feed")} />
            )}
            <footer className="mt-8 text-sm text-gray-500">å‰ç«¯æ¼”ç¤º â€” å·²æ¥å…¥å¤šä¸ªæ¥æºï¼ˆè§ä»£ç æ³¨é‡Šï¼‰ã€‚è‹¥æ— æ³•æ˜¾ç¤ºå›¾ç‰‡ï¼Œé€šå¸¸æ˜¯ CORS æˆ–éœ€ API Keyã€‚å¯åœ¨æœ¬åœ°ç”¨ dev proxy è§£å†³ã€‚æ–°å¢æ—¶é—´ç­›é€‰ï¼ˆåŸºäºå¯ç”¨æ—¥æœŸå­—æ®µï¼‰ã€‚</footer>
          </main>
        </div>
      );
    }

    function FeedPage({ loading, error, filteredFeed, activeTab, setActiveTab, timeFilter, setTimeFilter }) {
      return (
        <section>
          <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
            <div className="flex gap-2">
              <Tab label="æµ·å¤–" active={activeTab === "foreign"} onClick={() => setActiveTab("foreign")} />
              <Tab label="å›½å†…" active={activeTab === "domestic"} onClick={() => setActiveTab("domestic")} />
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm text-gray-400">æ—¶é—´ç­›é€‰ï¼š</label>
              <select
                value={timeFilter}
                onChange={(e) => setTimeFilter(e.target.value)}
                className="px-2 py-1 rounded bg-gray-800 text-sm"
              >
                <option value="all">å…¨éƒ¨</option>
                <option value="today">ä»Šå¤©</option>
                <option value="week">ä¸€å‘¨å†…</option>
                <option value="month">ä¸€æœˆå†…</option>
              </select>
            </div>
            <div className="text-sm text-gray-400">å¤šæ¥æºåˆå¹¶ Â· çº¯å‰ç«¯</div>
          </div>
          {loading && <div className="py-12 text-center">æŠ“æ¢—ä¸­... ğŸœ</div>}
          {error && <div className="py-4 text-red-400">{error}</div>}
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {filteredFeed.map((m) => (
              <MemeCard key={m.id} meme={m} />
            ))}
          </div>
          {filteredFeed.length === 0 && !loading && (
            <div className="py-12 text-center text-gray-400">æ— åŒ¹é…ç»“æœï¼Œå°è¯•è°ƒæ•´ç­›é€‰æˆ–åˆ·æ–°ã€‚</div>
          )}
        </section>
      );
    }

    function Tab({ label, active, onClick }) {
      return (
        <button onClick={onClick} className={`px-3 py-1 rounded ${active ? "bg-indigo-600 text-white" : "bg-gray-800"}`}>
          {label}
        </button>
      );
    }

    function MemeCard({ meme }) {
      const [show, setShow] = useState(false);
      return (
        <article className="bg-gray-800 p-2 rounded shadow-sm overflow-hidden hover:scale-[1.01] transition-transform">
          <div className="relative w-full h-48 bg-gray-700 rounded overflow-hidden">
            <img
              src={meme.url}
              alt={meme.title}
              className="w-full h-full object-cover"
              onLoad={() => setShow(true)}
              onError={() => setShow(true)}
            />
            {!show && <div className="absolute inset-0 flex items-center justify-center">åŠ è½½ä¸­...</div>}
          </div>
          <div className="mt-2">
            <div className="text-sm font-semibold truncate">{meme.title}</div>
            <div className="text-xs text-gray-400 flex justify-between">
              <span>{meme.source || "source"}</span>
              {meme.date && <span className="text-gray-500">{meme.date}</span>}
            </div>
          </div>
        </article>
      );
    }

    function GamePage({ feedImages, onBack }) {
      const [running, setRunning] = useState(false);
      const [score, setScore] = useState(0);
      const [objects, setObjects] = useState([]);
      const rafRef = useRef(null);

      useEffect(() => {
        return () => cancelAnimationFrame(rafRef.current || 0);
      }, []);

      function start() {
        setScore(0);
        setObjects(generateObjectsFromFeed(feedImages || []));
        setRunning(true);
        rafRef.current = requestAnimationFrame(tick);
      }

      function stop() {
        setRunning(false);
        cancelAnimationFrame(rafRef.current || 0);
      }

      function tick() {
        setObjects((prev) => {
          const next = prev
            .map((o) => ({ ...o, y: o.y + o.speed }))
            .filter((o) => o.y < 110);
          return next;
        });
        if (running) rafRef.current = requestAnimationFrame(tick);
      }

      function handleCollect(id) {
        setScore((s) => s + 1);
        setObjects((prev) => prev.filter((o) => o.id !== id));
      }

      return (
        <section>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              <button onClick={onBack} className="px-3 py-1 rounded bg-gray-800">è¿”å›</button>
              <div className="text-lg font-semibold">æ¢—çŒæ‰‹ Â· ç‚¹å‡»æ”¶é›†éšæœºçƒ­æ¢—</div>
            </div>
            <div className="text-right">
              <div className="text-sm text-gray-400">åˆ†æ•°ï¼š{score}</div>
              <div className="mt-2">
                {!running ? (
                  <button onClick={start} className="px-3 py-1 rounded bg-indigo-600">å¼€å§‹</button>
                ) : (
                  <button onClick={stop} className="px-3 py-1 rounded bg-red-600">åœæ­¢</button>
                )}
              </div>
            </div>
          </div>
          <div className="relative h-[60vh] bg-gradient-to-b from-gray-900 via-gray-800 to-gray-900 rounded overflow-hidden border border-gray-800">
            {objects.map((o) => (
              <FloatingMeme key={o.id} obj={o} onCollect={() => handleCollect(o.id)} />
            ))}
            <div className="absolute top-4 left-4 text-xs text-gray-400">Hit the memes for points â€” assets from filtered feed</div>
          </div>
          <div className="mt-4 text-sm text-gray-500">æç¤ºï¼šè‹¥æ¸¸æˆæ— å›¾ç‰‡ï¼Œè¯·å…ˆåœ¨â€œçƒ­æ¢—å¢™â€åˆ·æ–°å¹¶é€‰æ ‡ç­¾/æ—¶é—´ï¼Œè¿™é‡Œä¼šä½¿ç”¨å½“å‰ç­›é€‰çš„ç´ æã€‚</div>
        </section>
      );
    }

    function FloatingMeme({ obj, onCollect }) {
      const style = {
        left: `${obj.x}%`,
        top: `${obj.y}%`,
        width: `${obj.size}px`,
        height: `${obj.size}px`,
      };
      return (
        <div
          className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer rounded overflow-hidden shadow-lg"
          style={style}
          onClick={onCollect}
          title={obj.title}
        >
          <img src={obj.url} alt={obj.title} className="w-full h-full object-cover" />
        </div>
      );
    }

    // -------------------------- Fetching and source logic --------------------------
    // Helpers: timeout fetch
    async function fetchWithTimeout(url, opts = {}, timeout = 8000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        clearTimeout(id);
        return res;
      } finally {
        clearTimeout(id);
      }
    }

    async function tryFetchSources(sources) {
      // sources: [{name, url, parser: async (resp)=>[] , method?, headers?, resType?}]
      for (const s of sources) {
        try {
          const res = await fetchWithTimeout(s.url, { method: s.method || "GET", headers: s.headers || {} }, s.timeout || 9000);
          if (!res.ok) throw new Error(`${s.name} status ${res.status}`);
          const data = await res[s.resType || "json"]();
          const imgs = await s.parser(data);
          if (Array.isArray(imgs) && imgs.length > 0) {
            console.info(`source ${s.name} success, got ${imgs.length}`);
            return imgs;
          }
        } catch (e) {
          console.warn(`source ${s.name} failed:`, e);
          // try next
        }
      }
      return [];
    }

    async function tryFetchForeignImages() {
      // Define multiple overseas sources with parsers (enhanced with date where possible)
      const sources = [
        // Meme API (D3vd) - simple gimme endpoint (no date available)
        {
          name: "MemeAPI_gimme",
          url: "https://meme-api.com/gimme/50",
          parser: async (d) => {
            // if gimme returns a list or single
            const arr = Array.isArray(d.memes || d) ? (d.memes || d) : (d ? [d] : []);
            const out = (arr || []).map((p, i) => ({ 
              id: p.postLink || `memeapi-${i}`, 
              title: p.title || "meme", 
              url: p.url, 
              source: p.subreddit || "meme-api",
              date: null // no date in response
            })).filter(x => x.url);
            return out;
          },
        },
        // Imgflip templates (not user memes but usable, no date)
        {
          name: "Imgflip_templates",
          url: "https://api.imgflip.com/get_memes",
          parser: async (d) => {
            const memes = d?.data?.memes || [];
            return memes.map((m) => ({ 
              id: m.id, 
              title: m.name, 
              url: m.url, 
              source: "imgflip",
              date: null
            }));
          },
        },
        // Reddit top r/memes (with date from created_utc)
        {
          name: "Reddit_r_memes",
          url: "https://www.reddit.com/r/memes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url && (url.endsWith('.jpg') || url.endsWith('.png') || url.includes('i.redd.it') || url.includes('i.imgur.com') || url.startsWith('http'))) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
        // Reddit r/dankmemes (with date)
        {
          name: "Reddit_dank",
          url: "https://www.reddit.com/r/dankmemes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
        // Placeholder static pics (picsum) as last resort (no date)
        {
          name: "picsum_fallback",
          url: "https://picsum.photos/v2/list?page=2&limit=50",
          parser: async (d) => {
            return (d || []).map((p) => ({ 
              id: `picsum-${p.id}`, 
              title: p.author || "picsum", 
              url: `https://picsum.photos/id/${p.id}/800/600`, 
              source: "picsum",
              date: null
            }));
          },
          resType: 'json'
        },
      ];
      return await tryFetchSources(sources);
    }

    async function tryFetchDomesticImages() {
      // Domestic sources â€” many public domestic endpoints don't return image URLs directly.
      // We attempt a few aggregator endpoints (may require API key or CORS proxy).
      // Enhanced with date where possible (e.g., Bilibili pubdate).
      // Fill in YOUR_API_KEY where needed or use a server-side proxy.
      const ITAPI_KEY = ""; // optional: your itapi key
      const HUMOR_API_KEY = ""; // placeholder if you have keys for other services
      const sources = [
        // Example aggregator: itapi.cn (hot topics) â€” may return text hotspots (date if available)
        {
          name: "ITAPI_hot",
          url: ITAPI_KEY ? `https://api.itapi.cn/hot?api_key=${ITAPI_KEY}` : `https://api.itapi.cn/hot`,
          parser: async (d) => {
            // We try to derive images from returned topics; if none, return an empty array
            // NOTE: real response shapes differ â€” this is a best-effort placeholder parser.
            const items = d?.data || d || [];
            const out = [];
            for (let i = 0; i < Math.min(20, items.length); i++) {
              const t = items[i];
              // If the topic has an image field
              const img = t?.pic || t?.image || (t?.thumb && t.thumb[0]);
              if (img) {
                const date = t?.date || t?.time || null; // assume string date if present
                out.push({ id: `itapi-${i}`, title: t.title || t.keyword || "çƒ­æœ", url: img, source: "itapi", date });
              }
            }
            return out;
          },
        },
        // Bç«™/å“”å“©å“”å“© è§†é¢‘çƒ­æ¦œï¼ˆusing unofficial endpoints sometimes blockedï¼‰â€” with pubdate
        {
          name: "Bilibili_hot_videos",
          url: "https://api.bilibili.com/x/web-interface/ranking?rid=0&day=3&jsonp=jsonp",
          parser: async (d) => {
            const list = d?.data?.list || [];
            return list.map((v, i) => {
              const url = v?.pic || `https://i0.hdslb.com/bfs/archive/${v?.bvid || ''}.jpg`;
              const date = v?.pubdate ? new Date(v.pubdate * 1000).toDateString() : null;
              return { id: v?.aid || `b-${i}`, title: v?.title || "bç«™", url, source: "bilibili", date };
            }).filter(x => x.url);
          },
        },
        // Weibo çƒ­æœ apiï¼ˆéå®˜æ–¹ï¼‰ç¤ºä¾‹ â€” often blocked by CORS (no images/date)
        {
          name: "Weibo_hot_example",
          url: "https://weibo.com/ajax/statuses/hot_band",
          parser: async (d) => {
            // likely won't have images â€” skip
            return [];
          },
        },
        // Fallback: use picsum (å›½å†…ä¹Ÿå¯ç”¨) and local placeholders (no date)
        {
          name: "picsum_dom_fallback",
          url: "https://picsum.photos/v2/list?page=5&limit=50",
          parser: async (d) => {
            return (d || []).map((p) => ({ 
              id: `picsum-d-${p.id}`, 
              title: p.author || "picsum", 
              url: `https://picsum.photos/id/${p.id}/800/600`, 
              source: "picsum",
              date: null
            }));
          },
        },
        // Custom user-provided JSON endpoint (you can point this to your own proxy that scrapes Chinese platforms)
        {
          name: "custom_user_json",
          url: window.__MEMEWAVE_CUSTOM_JSON_URL || "https://yourdomain.com/memes.json",
          parser: async (d) => {
            // Expect array of {title, url, date?}
            if (!Array.isArray(d)) return [];
            return d.map((it, i) => ({ 
              id: it.id || `custom-${i}`, 
              title: it.title || it.text || 'custom', 
              url: it.url, 
              source: 'custom',
              date: it.date || null
            })).filter(x => x.url);
          },
        },
      ];
      return await tryFetchSources(sources);
    }

    // Utilities
    function shuffleArray(a) {
      const arr = [...a];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function generateObjectsFromFeed(feed) {
      if (!feed || feed.length === 0) return [];
      const objs = [];
      const sample = shuffleArray(feed).slice(0, 30);
      for (let i = 0; i < sample.length; i++) {
        const s = sample[i];
        objs.push({
          id: `o-${s.id}-${i}`,
          url: s.url,
          title: s.title,
          x: Math.random() * 90 + 5,
          y: Math.random() * 10 + -10,
          size: 60 + Math.random() * 120,
          speed: 0.2 + Math.random() * 1.2,
        });
      }
      return objs;
    }

    // Render the app
    ReactDOM.render(<MemeWaveApp />, document.getElementById('root'));
  </script>
</body>
</html>
