<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MemeWave - made by Giu Giu</title>
  <link rel="icon" href="https://tse4.mm.bing.net/th/id/OIP.piRzWtMCSbpX-WL21vFMSgAAAA?rs=1&pid=ImgDetMain&o=7&rm=3" type="image/jpeg">
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom styles if needed beyond Tailwind */
  </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen">
  <div id="root"></div>
  <script type="text/babel">
    // MemeWave â€” single-file React front-end (standalone HTML version)
    // Dark theme, 1 page: Feed + Anime
    // Integrates multiple overseas + domestic sources with automatic fallback & retry logic.
    // Added: Time filter (All, Today, Week, Month) â€” client-side based on meme dates where available.
    // Added: Click on feed images to view full size in modal.
    // Added: ä½œè€…åœ¨çœ‹çš„ç•ª page.
    // Added: Infinite scroll â€” load more when scroll to bottom.
    // Added: Background caching â€” preload inactive tab in background every 10s if <200 items.
    // Added: Language switcher (ZH/EN) in header.
    // Added: Credits page with production staff list.
    // Added: Boy Kisser button in header â€” image-only, clicks to modal with full Boy Kisser emoji image.
    // Updated: Domestic sources now include Bilibili as fallback (memes.tw is JS-heavy, may not load images via fetch).
    // Updated: Improved title extraction for Bilibili - use desc/title or user name + "çš„å›¾ç‰‡" as fallback for better titles.
    // Updated: For memes.tw, fallback title to "å°æ¹¾çƒ­æ¢— X" if no text found (though static parse may yield few results).
    // Updated: Added "(Unstable)" label to Domestic tab button (lang-aware: "(ä¸ç¨³å®š)" for ZH).
    // NOTE: This is still a front-end-only demo. CORS and API keys may be required for some sources.
    // Usage: Open index.html in browser (use dev proxy for CORS if needed).
    const { useEffect, useState, useRef, useMemo, useCallback } = React;
    function MemeWaveApp() {
      const [route, setRoute] = useState("feed");
      const [lang, setLang] = useState("zh"); // 'zh' or 'en'
      const [foreignFeed, setForeignFeed] = useState([]);
      const [domesticFeed, setDomesticFeed] = useState([]);
      const [loading, setLoading] = useState(false);
      const [activeTab, setActiveTab] = useState("foreign");
      const [timeFilter, setTimeFilter] = useState("all");
      const [error, setError] = useState(null);
      const [selectedMeme, setSelectedMeme] = useState(null);
      const [showBoyKisser, setShowBoyKisser] = useState(false);
      const [hasMoreForeign, setHasMoreForeign] = useState(false);
      const [hasMoreDomestic, setHasMoreDomestic] = useState(false);
      const [isLoadingMore, setIsLoadingMore] = useState(false);
      const [backgroundInterval, setBackgroundInterval] = useState(null);
      useEffect(() => {
        loadFeeds();
      }, []);
      useEffect(() => {
        if (backgroundInterval) clearInterval(backgroundInterval);
        const interval = setInterval(() => {
          const inactiveTab = activeTab === "foreign" ? "domestic" : "foreign";
          const inactiveFeed = inactiveTab === "foreign" ? foreignFeed : domesticFeed;
          const inactiveHasMore = inactiveTab === "foreign" ? hasMoreForeign : hasMoreDomestic;
          if (inactiveFeed.length < 200 && inactiveHasMore && !isLoadingMore) {
            loadMoreFeed(inactiveTab);
          }
        }, 10000); // Preload inactive every 10s
        setBackgroundInterval(interval);
        return () => clearInterval(interval);
      }, [activeTab, foreignFeed.length, domesticFeed.length, hasMoreForeign, hasMoreDomestic, isLoadingMore, loadMoreFeed]);
      async function loadFeeds() {
        setLoading(true);
        setError(null);
        try {
          const fImgs = await tryFetchForeignImages();
          const dImgs = await tryFetchDomesticImages();
          setForeignFeed(shuffleArray(fImgs).slice(0, 40));
          setHasMoreForeign(fImgs.length >= 40);
          setDomesticFeed(shuffleArray(dImgs).slice(0, 40));
          setHasMoreDomestic(dImgs.length >= 40);
        } catch (e) {
          console.error(e);
          setError(lang === 'en' ? "Failed to load some memes. Check console. Might be CORS or API Key required." : "åŠ è½½éƒ¨åˆ†æ¢—å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚å¯èƒ½æ˜¯ CORS æˆ–æ¥å£éœ€è¦ API Keyã€‚");
        } finally {
          setLoading(false);
        }
      }
      const loadMoreFeed = useCallback(async (tab) => {
        if (isLoadingMore) return;
        const hasMore = tab === "foreign" ? hasMoreForeign : hasMoreDomestic;
        if (!hasMore) return;
        setIsLoadingMore(true);
        try {
          let moreImgs;
          if (tab === "foreign") {
            moreImgs = await tryFetchForeignImages();
          } else {
            moreImgs = await tryFetchDomesticImages();
          }
          const currentFeedState = tab === "foreign" ? foreignFeed : domesticFeed;
          const newMemes = moreImgs.filter(m => !currentFeedState.some(c => c.id === m.id));
          const toAdd = shuffleArray(newMemes).slice(0, 20);
          const updatedFeed = [...currentFeedState, ...toAdd];
          if (tab === "foreign") {
            setForeignFeed(updatedFeed);
            setHasMoreForeign(toAdd.length > 0 || moreImgs.length >= 20);
          } else {
            setDomesticFeed(updatedFeed);
            setHasMoreDomestic(toAdd.length > 0 || moreImgs.length >= 20);
          }
        } catch (e) {
          console.error(e);
        } finally {
          setIsLoadingMore(false);
        }
      }, [foreignFeed, domesticFeed, hasMoreForeign, hasMoreDomestic, isLoadingMore]);
      const currentFeed = activeTab === "foreign" ? foreignFeed : domesticFeed;
      const filteredFeed = useMemo(() => {
        const now = new Date();
        return currentFeed.filter((m) => {
          if (timeFilter === "all" || !m.date) return true;
          const mDate = new Date(m.date);
          switch (timeFilter) {
            case "today":
              return mDate.toDateString() === now.toDateString();
            case "week":
              return mDate > new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            case "month":
              return mDate > new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            default:
              return true;
          }
        });
      }, [currentFeed, timeFilter]);
      const hasMore = activeTab === "foreign" ? hasMoreForeign : hasMoreDomestic;
      const t = (key) => {
        const translations = {
          zh: {
            title: "MemeWave",
            hotMemes: "çƒ­æ¢—å¢™",
            animeWatching: "ä½œè€…åœ¨çœ‹çš„ç•ª",
            credits: "åˆ¶ä½œåå•",
            boyKisser: "Boy Kisser",
            refresh: "åˆ·æ–°æ¢—",
            overseas: "æµ·å¤–",
            domestic: "å›½å†…",
            unstable: "(ä¸ç¨³å®š)",
            timeFilter: "æ—¶é—´ç­›é€‰ï¼š",
            all: "å…¨éƒ¨",
            today: "ä»Šå¤©",
            week: "ä¸€å‘¨å†…",
            month: "ä¸€æœˆå†…",
            loading: "æŠ“æ¢—ä¸­... ğŸœ",
            noResults: "æ— åŒ¹é…ç»“æœï¼Œå°è¯•è°ƒæ•´ç­›é€‰æˆ–åˆ·æ–°ã€‚",
            end: "~ åˆ°åº•äº† ~",
            loadingMore: "åŠ è½½æ›´å¤š...",
            multiSource: "å¤šæ¥æºåˆå¹¶ Â· çº¯å‰ç«¯",
            back: "è¿”å›",
            animeTitle: "ä½œè€…åœ¨çœ‹çš„ç•ª",
            footer: "å‰ç«¯æ¼”ç¤º â€” å·²æ¥å…¥å¤šä¸ªæ¥æºï¼ˆè§ä»£ç æ³¨é‡Šï¼‰ã€‚è‹¥æ— æ³•æ˜¾ç¤ºå›¾ç‰‡ï¼Œé€šå¸¸æ˜¯ CORS æˆ–éœ€ API Keyã€‚å¯åœ¨æœ¬åœ°ç”¨ dev proxy è§£å†³ã€‚æ–°å¢æ—¶é—´ç­›é€‰ï¼ˆåŸºäºå¯ç”¨æ—¥æœŸå­—æ®µï¼‰åŠå›¾ç‰‡ç‚¹å‡»æŸ¥çœ‹å¤§å›¾ã€‚æ–°å¢æ— é™æ»šåŠ¨åŠ è½½åŠåå°ç¼“å­˜é¢„åŠ è½½ã€‚å›½å†…æ¥æºï¼šmemes.tw (é™æ€æŠ“å–æœ‰é™) + Bilibili åŠ¨æ€å›¾ç‰‡ï¼ˆä¼˜åŒ–æ ‡é¢˜æå–ï¼‰ã€‚",
            animeDesc: "å½“å®…ç”·å“¥å“¥ä¸å°å¿ƒç”¨å¯ç–‘è¯ç‰©æŠŠè‡ªå·±çš„å“¥å“¥å˜æˆäº†å¥³å­©å­åï¼Œå±•å¼€çš„çˆ†ç¬‘æ—¥å¸¸æ•…äº‹ã€‚",
            episodes: "Season 1",
            status: "Watching",
            animeListNote: "Giu Giu çš„è¿½ç•ªåˆ—è¡¨ â€” åŸºäº MyAnimeList æ•°æ®ï¼Œçº¯é™æ€å±•ç¤ºã€‚",
          },
          en: {
            title: "MemeWave",
            hotMemes: "Hot Memes",
            animeWatching: "Anime I'm Watching",
            credits: "Credits",
            boyKisser: "Boy Kisser",
            refresh: "Refresh Memes",
            overseas: "Overseas",
            domestic: "Domestic",
            unstable: "(Unstable)",
            timeFilter: "Time Filter:",
            all: "All",
            today: "Today",
            week: "This Week",
            month: "This Month",
            loading: "Fetching memes... ğŸœ",
            noResults: "No matching results. Try adjusting filter or refresh.",
            end: "~ End of feed ~",
            loadingMore: "Loading more...",
            multiSource: "Multi-source Â· Pure Frontend",
            back: "Back",
            animeTitle: "Anime I'm Watching",
            footer: "Frontend demo â€” Integrated multiple sources (see code comments). If images fail to load, it's usually CORS or API Key needed. Solve with local dev proxy. Added time filtering (based on available date fields) and image click to view full size. Added infinite scroll and background caching preload. Domestic: memes.tw (limited static scrape) + Bilibili dynamic images (improved title extraction).",
            animeDesc: "After a shut-in brother accidentally turns his brother into a girl with suspicious drugs, an explosive daily life story unfolds.",
            episodes: "Season 1",
            status: "Watching",
            animeListNote: "Giu Giu's anime watchlist â€” Based on MyAnimeList data, static display.",
          }
        };
        return translations[lang][key] || key;
      };
      const boyKisserMeme = {
        id: "boykisser",
        title: t('boyKisser'),
        url: "https://tse4.mm.bing.net/th/id/OIP.piRzWtMCSbpX-WL21vFMSgAAAA?rs=1&pid=ImgDetMain&o=7&rm=3",
        source: "Boy Kisser"
      };
      return (
        <div className="min-h-screen bg-gray-900 text-gray-100 font-sans">
          <header className="p-4 flex items-center justify-between border-b border-gray-800">
            <h1 className="text-2xl font-bold tracking-tight">{t('title')}</h1>
            <nav className="flex items-center gap-2">
              <button onClick={() => setRoute("feed")} className={`px-3 py-1 rounded-md ${route === "feed" ? "bg-gray-800" : "bg-transparent"}`}>
                {t('hotMemes')}
              </button>
              <button onClick={() => setRoute("anime")} className={`px-3 py-1 rounded-md ${route === "anime" ? "bg-gray-800" : "bg-transparent"}`}>
                {t('animeWatching')}
              </button>
              <button onClick={() => setRoute("credits")} className={`px-3 py-1 rounded-md ${route === "credits" ? "bg-gray-800" : "bg-transparent"}`}>
                {t('credits')}
              </button>
              <button onClick={loadFeeds} className="px-3 py-1 rounded-md bg-gray-800 ml-2">{t('refresh')}</button>
              <button
                onClick={() => setLang(lang === 'zh' ? 'en' : 'zh')}
                className="px-3 py-1 rounded-md bg-indigo-600 ml-2 text-sm"
              >
                {lang === 'zh' ? 'EN' : 'ZH'}
              </button>
              <button
                onClick={() => setShowBoyKisser(true)}
                className="p-1 rounded hover:bg-gray-800 transition-colors ml-2"
                title={t('boyKisser')}
              >
                <img
                  src="https://tse4.mm.bing.net/th/id/OIP.piRzWtMCSbpX-WL21vFMSgAAAA?rs=1&pid=ImgDetMain&o=7&rm=3"
                  alt={t('boyKisser')}
                  className="w-8 h-8 rounded"
                />
              </button>
            </nav>
          </header>
          <main className="p-6">
            {route === "feed" ? (
              <FeedPage
                loading={loading}
                error={error}
                filteredFeed={filteredFeed}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
                timeFilter={timeFilter}
                setTimeFilter={setTimeFilter}
                selectedMeme={selectedMeme}
                setSelectedMeme={setSelectedMeme}
                loadMore={loadMoreFeed}
                hasMore={hasMore}
                isLoadingMore={isLoadingMore}
                t={t}
              />
            ) : route === "credits" ? (
              <CreditsPage onBack={() => setRoute("feed")} t={t} />
            ) : (
              <AnimePage onBack={() => setRoute("feed")} t={t} />
            )}
            {selectedMeme && (
              <ImageModal meme={selectedMeme} onClose={() => setSelectedMeme(null)} t={t} />
            )}
            {showBoyKisser && (
              <ImageModal meme={boyKisserMeme} onClose={() => setShowBoyKisser(false)} t={t} />
            )}
            <footer className="mt-8 text-sm text-gray-500">{t('footer')}</footer>
          </main>
        </div>
      );
    }
    function CreditsPage({ onBack, t }) {
      return (
        <section>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              <button onClick={onBack} className="px-3 py-1 rounded bg-gray-800">{t('back')}</button>
              <div className="text-lg font-semibold">{t('credits')}</div>
            </div>
          </div>
          <div className="bg-gray-800 p-6 rounded shadow-sm">
            <h2 className="text-xl font-bold mb-4">Production Staff</h2>
            <ul className="space-y-2 text-sm">
              <li><strong>Author:</strong> Giu Giu</li>
              <li><strong>Helpers:</strong> GPT and Grok (just API)</li>
              <li><strong>IDK:</strong> IDK</li>
            </ul>
          </div>
        </section>
      );
    }
    function FeedPage({ loading, error, filteredFeed, activeTab, setActiveTab, timeFilter, setTimeFilter, selectedMeme, setSelectedMeme, loadMore, hasMore, isLoadingMore, t }) {
      const sentinelRef = useRef(null);
      useEffect(() => {
        const observer = new IntersectionObserver(
          ([entry]) => {
            if (entry.isIntersecting && hasMore && !isLoadingMore) {
              loadMore(activeTab);
            }
          },
          { threshold: 0.1 }
        );
        if (sentinelRef.current) {
          observer.observe(sentinelRef.current);
        }
        return () => {
          if (sentinelRef.current) {
            observer.unobserve(sentinelRef.current);
          }
        };
      }, [hasMore, isLoadingMore, activeTab, loadMore]);
      return (
        <section>
          <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
            <div className="flex gap-2">
              <Tab label={t('overseas')} active={activeTab === "foreign"} onClick={() => setActiveTab("foreign")} />
              <Tab 
                label={`${t('domestic')} ${t('unstable')}`} 
                active={activeTab === "domestic"} 
                onClick={() => setActiveTab("domestic")} 
              />
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm text-gray-400">{t('timeFilter')}</label>
              <select
                value={timeFilter}
                onChange={(e) => setTimeFilter(e.target.value)}
                className="px-2 py-1 rounded bg-gray-800 text-sm"
              >
                <option value="all">{t('all')}</option>
                <option value="today">{t('today')}</option>
                <option value="week">{t('week')}</option>
                <option value="month">{t('month')}</option>
              </select>
            </div>
            <div className="text-sm text-gray-400">{t('multiSource')}</div>
          </div>
          {loading && <div className="py-12 text-center">{t('loading')}</div>}
          {error && <div className="py-4 text-red-400">{error}</div>}
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {filteredFeed.map((m) => (
              <MemeCard key={m.id} meme={m} onClick={() => setSelectedMeme(m)} />
            ))}
          </div>
          {hasMore && (
            <div ref={sentinelRef} className="h-20 flex justify-center items-center">
              {isLoadingMore ? <div className="text-gray-400">{t('loadingMore')}</div> : <div className="text-gray-500">{t('end')}</div>}
            </div>
          )}
          {filteredFeed.length === 0 && !loading && (
            <div className="py-12 text-center text-gray-400">{t('noResults')}</div>
          )}
        </section>
      );
    }
    function Tab({ label, active, onClick }) {
      return (
        <button onClick={onClick} className={`px-3 py-1 rounded ${active ? "bg-indigo-600 text-white" : "bg-gray-800"}`}>
          {label}
        </button>
      );
    }
    function MemeCard({ meme, onClick }) {
      const [show, setShow] = useState(false);
      return (
        <article
          className="bg-gray-800 p-2 rounded shadow-sm overflow-hidden hover:scale-[1.01] transition-transform cursor-pointer"
          onClick={onClick}
        >
          <div className="relative w-full h-48 bg-gray-700 rounded overflow-hidden">
            <img
              src={meme.url}
              alt={meme.title}
              className="w-full h-full object-cover"
              onLoad={() => setShow(true)}
              onError={() => setShow(true)}
            />
            {!show && <div className="absolute inset-0 flex items-center justify-center">Loading...</div>}
          </div>
          <div className="mt-2">
            <div className="text-sm font-semibold truncate">{meme.title}</div>
            <div className="text-xs text-gray-400 flex justify-between">
              <span>{meme.source || "source"}</span>
              {meme.date && <span className="text-gray-500">{meme.date}</span>}
            </div>
          </div>
        </article>
      );
    }
    function ImageModal({ meme, onClose, t }) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
          <div className="relative max-w-4xl max-h-full p-4">
            <button
              onClick={onClose}
              className="absolute top-2 right-2 text-white text-4xl font-bold z-10 px-2 py-1 rounded hover:bg-gray-800 transition-colors"
            >
              Ã—
            </button>
            <img
              src={meme.url}
              alt={meme.title}
              className="max-w-full max-h-[90vh] object-contain rounded shadow-lg"
            />
            <div className="mt-4 text-center text-white">
              <h3 className="text-lg font-semibold">{meme.title}</h3>
              <p className="text-sm text-gray-300">{meme.source || "source"}</p>
              {meme.date && <p className="text-sm text-gray-400">{meme.date}</p>}
            </div>
          </div>
        </div>
      );
    }
    function AnimePage({ onBack, t }) {
      const animeList = [
        {
          id: 1,
          title: "Onimai (ãŠå…„ã¡ã‚ƒã‚“ã¯ãŠã—ã¾ã„ï¼)",
          poster: "https://tse4.mm.bing.net/th/id/OIP.uFVmquY49ImPRvhtYB5SeQHaKb?rs=1&pid=ImgDetMain&o=7&rm=3",
          description: t('animeDesc'),
          episodes: t('episodes'),
          status: t('status'),
          url: "https://onimai.jp/"
        }
      ];
      return (
        <section>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              <button onClick={onBack} className="px-3 py-1 rounded bg-gray-800">{t('back')}</button>
              <div className="text-lg font-semibold">{t('animeTitle')}</div>
            </div>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {animeList.map((anime) => (
              <AnimeCard key={anime.id} anime={anime} />
            ))}
          </div>
          <div className="mt-4 text-sm text-gray-500">{t('animeListNote')}</div>
        </section>
      );
    }
    function AnimeCard({ anime }) {
      const [show, setShow] = useState(false);
      const handleClick = () => {
        window.location.href = anime.url;
      };
      return (
        <article onClick={handleClick} className="bg-gray-800 p-2 rounded shadow-sm overflow-hidden hover:scale-[1.01] transition-transform cursor-pointer">
          <div className="relative w-full h-48 bg-gray-700 rounded overflow-hidden">
            <img
              src={anime.poster}
              alt={anime.title}
              className="w-full h-full object-cover"
              onLoad={() => setShow(true)}
              onError={() => setShow(true)}
            />
            {!show && <div className="absolute inset-0 flex items-center justify-center">Loading...</div>}
          </div>
          <div className="mt-2">
            <div className="text-sm font-semibold truncate">{anime.title}</div>
            <div className="text-xs text-gray-400">{anime.status}</div>
            <div className="text-xs text-gray-500 mt-1 line-clamp-2">{anime.description}</div>
            <div className="text-xs text-indigo-400 mt-1">{anime.episodes}</div>
          </div>
        </article>
      );
    }
    // -------------------------- Fetching and source logic --------------------------
    // Helpers: timeout fetch
    async function fetchWithTimeout(url, opts = {}, timeout = 8000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        clearTimeout(id);
        return res;
      } finally {
        clearTimeout(id);
      }
    }
    async function tryFetchSources(sources) {
      let allImgs = [];
      for (const s of sources) {
        try {
          const res = await fetchWithTimeout(s.url, { method: s.method || "GET", headers: s.headers || {} }, s.timeout || 9000);
          if (!res.ok) throw new Error(`${s.name} status ${res.status}`);
          const data = await res[s.resType || "json"]();
          const imgs = await s.parser(data);
          if (Array.isArray(imgs) && imgs.length > 0) {
            allImgs = allImgs.concat(imgs);
            console.info(`source ${s.name} added ${imgs.length}`);
          }
        } catch (e) {
          console.warn(`source ${s.name} failed:`, e);
        }
      }
      return allImgs;
    }
    async function tryFetchForeignImages() {
      const sources = [
        {
          name: "MemeAPI_gimme",
          url: "https://meme-api.com/gimme/50",
          parser: async (d) => {
            const arr = Array.isArray(d.memes || d) ? (d.memes || d) : (d ? [d] : []);
            const out = (arr || []).map((p, i) => ({
              id: p.postLink || `memeapi-${i}`,
              title: p.title || "meme",
              url: p.url,
              source: p.subreddit || "meme-api",
              date: null
            })).filter(x => x.url);
            return out;
          },
        },
        {
          name: "Imgflip_templates",
          url: "https://api.imgflip.com/get_memes",
          parser: async (d) => {
            const memes = d?.data?.memes || [];
            return memes.map((m) => ({
              id: m.id,
              title: m.name,
              url: m.url,
              source: "imgflip",
              date: null
            }));
          },
        },
        {
          name: "Reddit_r_memes",
          url: "https://www.reddit.com/r/memes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url && (url.endsWith('.jpg') || url.endsWith('.png') || url.includes('i.redd.it') || url.includes('i.imgur.com') || url.startsWith('http'))) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
        {
          name: "Reddit_dank",
          url: "https://www.reddit.com/r/dankmemes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
      ];
      return await tryFetchSources(sources);
    }
    async function tryFetchDomesticImages() {
      // Domestic sources â€” memes.tw (may be limited due to JS rendering) + Bilibili dynamic images
      const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
      const targetUrl = 'https://memes.tw/';
      const sources = [
        {
          name: "memes.tw",
          url: CORS_PROXY + encodeURIComponent(targetUrl),
          resType: "text",
          timeout: 10000,
          parser: async (html) => {
            console.log("Parsing memes.tw HTML...");
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            // Enhanced selectors for memes.tw - trying more patterns based on common blog/meme site structures
            const memeElements = doc.querySelectorAll('img[src*="jpg"], img[src*="png"], img[data-src*="jpg"], img[data-src*="png"], .entry-content img, .post-content img, .meme-container img, article img, .wp-post-image');
            const out = [];
            let i = 0;
            for (const img of memeElements) {
              if (i >= 50) break;
              let src = img.src || img.getAttribute('data-src') || img.getAttribute('data-lazy-src') || img.getAttribute('srcset')?.split(',')[0]?.trim().split(' ')[0];
              if (!src) continue;
              // Clean up srcset if present
              if (src.includes('srcset')) src = src.split(',')[0].trim().split(' ')[0];
              if (src && (src.includes('.jpg') || src.includes('.png') || src.includes('.gif')) && !src.includes('avatar') && !src.includes('logo') && !src.includes('icon') && !src.includes('wp-includes')) {
                // Find parent for title and date
                let parent = img.closest('article, .post, .entry, .meme, .item, .card, div[class*="post"], div[class*="entry"], section') || img.parentElement;
                if (!parent) parent = img;
                let titleEl = parent.querySelector('h1, h2, h3, h4, .title, .headline, .post-title, .entry-title, p, .caption') || img;
                let title = (titleEl.textContent || titleEl.alt || titleEl.title || `å°æ¹¾çƒ­æ¢— ${i + 1}`).trim().substring(0, 50);
                if (!title || title.length < 3) title = `å°æ¹¾çƒ­æ¢— ${i + 1}`;
                let dateEl = parent.querySelector('.date, .time, time, .published, [datetime], .post-date') || parent.querySelector('time');
                let date = dateEl ? (dateEl.textContent || dateEl.getAttribute('datetime')).trim() : null;
                if (date && !date.includes('Date')) date = new Date(date).toDateString() || date;
                // Resolve URL
                let fullUrl;
                try {
                  fullUrl = src.startsWith('http') ? src : new URL(src, targetUrl).href;
                } catch (e) {
                  console.warn("Invalid URL:", src);
                  continue;
                }
                out.push({
                  id: `memes-${i}-${Date.now()}`,
                  title,
                  url: fullUrl,
                  source: "memes.tw",
                  date
                });
                i++;
              }
            }
            console.log(`Parsed ${out.length} memes from memes.tw. Sample:`, out.slice(0, 2));
            if (out.length === 0) {
              console.warn("No images from memes.tw - site likely JS-heavy, consider browser extension or proxy for full render.");
            }
            return out.filter(x => x.url && x.url.length > 10 && !x.url.includes('data:image'));
          },
        },
        {
          name: "Bilibili_dynamic",
          url: "https://api.bilibili.com/x/polymer/web-dynamic/v1/feed/all?type=1688&pn=1", // type=1688 for image-only dynamics
          headers: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
          },
          parser: async (d) => {
            const items = d?.data?.items || [];
            const out = [];
            for (const item of items) {
              const modules = item?.modules?.module_dynamic || {};
              const major = modules?.major || {};
              let pic = null;
              let title = null;
              // Check for draw (image post)
              const draw = major?.draw || {};
              if (draw?.items && draw.items.length > 0) {
                pic = draw.items[0]?.src;
                title = draw.desc || null;
              }
              // Fallback to archive cover (if it's a video with cover image)
              if (!pic) {
                const archive = major?.archive || {};
                pic = archive?.cover;
                title = archive?.title?.text || null;
              }
              if (pic && (pic.includes('.jpg') || pic.includes('.png'))) {
                const id = item.id_str || `bili-${Math.random().toString(36).substr(2, 9)}`;
                // Improved title: prefer desc/title, fallback to user name + "çš„å›¾ç‰‡"
                if (!title) {
                  const user = item?.user || {};
                  title = user.name ? `${user.name}çš„å›¾ç‰‡` : "Bili åŠ¨æ€";
                }
                title = title.substring(0, 50);
                const date = major?.time ? new Date(major.time * 1000).toDateString() : null;
                out.push({
                  id,
                  title,
                  url: pic,
                  source: "bilibili",
                  date
                });
              }
            }
            console.log(`Parsed ${out.length} memes from Bilibili. Sample:`, out.slice(0, 2));
            return out;
          },
        },
      ];
      return await tryFetchSources(sources);
    }
    // Utilities
    function shuffleArray(a) {
      const arr = [...a];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    // Render the app
    ReactDOM.render(<MemeWaveApp />, document.getElementById('root'));
  </script>
</body>
</html>
