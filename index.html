<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MemeWave - made by Giu Giu</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom styles if needed beyond Tailwind */
  </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen">
  <div id="root"></div>
  <script type="text/babel">
    // MemeWave â€” single-file React front-end (standalone HTML version)
    // Dark theme, 1 page: Feed + Anime
    // Integrates multiple overseas + domestic sources with automatic fallback & retry logic.
    // Added: Time filter (All, Today, Week, Month) â€” client-side based on meme dates where available.
    // Added: Click on feed images to view full size in modal.
    // Added: ä½œè€…åœ¨çœ‹çš„ç•ª page.
    // NOTE: This is still a front-end-only demo. CORS and API keys may be required for some sources.
    // Usage: Open index.html in browser (use dev proxy for CORS if needed).

    const { useEffect, useState, useRef, useMemo } = React;

    function MemeWaveApp() {
      const [route, setRoute] = useState("feed");
      const [foreignFeed, setForeignFeed] = useState([]);
      const [domesticFeed, setDomesticFeed] = useState([]);
      const [loading, setLoading] = useState(false);
      const [activeTab, setActiveTab] = useState("foreign");
      const [timeFilter, setTimeFilter] = useState("all");
      const [error, setError] = useState(null);
      const [selectedMeme, setSelectedMeme] = useState(null);

      useEffect(() => {
        loadFeeds();
      }, []);

      async function loadFeeds() {
        setLoading(true);
        setError(null);
        try {
          const fImgs = await tryFetchForeignImages();
          const dImgs = await tryFetchDomesticImages();
          // ensure results are arrays of {id, title, url, source, date?}
          setForeignFeed(shuffleArray(fImgs).slice(0, 80));
          setDomesticFeed(shuffleArray(dImgs).slice(0, 80));
        } catch (e) {
          console.error(e);
          setError("åŠ è½½éƒ¨åˆ†æ¢—å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚å¯èƒ½æ˜¯ CORS æˆ–æ¥å£éœ€è¦ API Keyã€‚");
        } finally {
          setLoading(false);
        }
      }

      const currentFeed = activeTab === "foreign" ? foreignFeed : domesticFeed;

      const filteredFeed = useMemo(() => {
        const now = new Date();
        return currentFeed.filter((m) => {
          if (timeFilter === "all" || !m.date) return true;
          const mDate = new Date(m.date);
          switch (timeFilter) {
            case "today":
              return mDate.toDateString() === now.toDateString();
            case "week":
              return mDate > new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            case "month":
              return mDate > new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            default:
              return true;
          }
        });
      }, [currentFeed, timeFilter]);

      return (
        <div className="min-h-screen bg-gray-900 text-gray-100 font-sans">
          <header className="p-4 flex items-center justify-between border-b border-gray-800">
            <h1 className="text-2xl font-bold tracking-tight">MemeWave</h1>
            <nav className="flex items-center gap-2">
              <button onClick={() => setRoute("feed")} className={`px-3 py-1 rounded-md ${route === "feed" ? "bg-gray-800" : "bg-transparent"}`}>
                çƒ­æ¢—å¢™
              </button>
              <button onClick={() => setRoute("anime")} className={`px-3 py-1 rounded-md ${route === "anime" ? "bg-gray-800" : "bg-transparent"}`}>
                ä½œè€…åœ¨çœ‹çš„ç•ª
              </button>
              <button onClick={loadFeeds} className="px-3 py-1 rounded-md bg-gray-800 ml-2">åˆ·æ–°æ¢—</button>
            </nav>
          </header>
          <main className="p-6">
            {route === "feed" ? (
              <FeedPage
                loading={loading}
                error={error}
                filteredFeed={filteredFeed}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
                timeFilter={timeFilter}
                setTimeFilter={setTimeFilter}
                selectedMeme={selectedMeme}
                setSelectedMeme={setSelectedMeme}
              />
            ) : (
              <AnimePage onBack={() => setRoute("feed")} />
            )}
            {selectedMeme && (
              <ImageModal meme={selectedMeme} onClose={() => setSelectedMeme(null)} />
            )}
            <footer className="mt-8 text-sm text-gray-500">å‰ç«¯æ¼”ç¤º â€” å·²æ¥å…¥å¤šä¸ªæ¥æºï¼ˆè§ä»£ç æ³¨é‡Šï¼‰ã€‚è‹¥æ— æ³•æ˜¾ç¤ºå›¾ç‰‡ï¼Œé€šå¸¸æ˜¯ CORS æˆ–éœ€ API Keyã€‚å¯åœ¨æœ¬åœ°ç”¨ dev proxy è§£å†³ã€‚æ–°å¢æ—¶é—´ç­›é€‰ï¼ˆåŸºäºå¯ç”¨æ—¥æœŸå­—æ®µï¼‰åŠå›¾ç‰‡ç‚¹å‡»æŸ¥çœ‹å¤§å›¾ã€‚</footer>
          </main>
        </div>
      );
    }

    function FeedPage({ loading, error, filteredFeed, activeTab, setActiveTab, timeFilter, setTimeFilter, selectedMeme, setSelectedMeme }) {
      return (
        <section>
          <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
            <div className="flex gap-2">
              <Tab label="æµ·å¤–" active={activeTab === "foreign"} onClick={() => setActiveTab("foreign")} />
              <Tab label="å›½å†…" active={activeTab === "domestic"} onClick={() => setActiveTab("domestic")} />
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm text-gray-400">æ—¶é—´ç­›é€‰ï¼š</label>
              <select
                value={timeFilter}
                onChange={(e) => setTimeFilter(e.target.value)}
                className="px-2 py-1 rounded bg-gray-800 text-sm"
              >
                <option value="all">å…¨éƒ¨</option>
                <option value="today">ä»Šå¤©</option>
                <option value="week">ä¸€å‘¨å†…</option>
                <option value="month">ä¸€æœˆå†…</option>
              </select>
            </div>
            <div className="text-sm text-gray-400">å¤šæ¥æºåˆå¹¶ Â· çº¯å‰ç«¯</div>
          </div>
          {loading && <div className="py-12 text-center">æŠ“æ¢—ä¸­... ğŸœ</div>}
          {error && <div className="py-4 text-red-400">{error}</div>}
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {filteredFeed.map((m) => (
              <MemeCard key={m.id} meme={m} onClick={() => setSelectedMeme(m)} />
            ))}
          </div>
          {filteredFeed.length === 0 && !loading && (
            <div className="py-12 text-center text-gray-400">æ— åŒ¹é…ç»“æœï¼Œå°è¯•è°ƒæ•´ç­›é€‰æˆ–åˆ·æ–°ã€‚</div>
          )}
        </section>
      );
    }

    function Tab({ label, active, onClick }) {
      return (
        <button onClick={onClick} className={`px-3 py-1 rounded ${active ? "bg-indigo-600 text-white" : "bg-gray-800"}`}>
          {label}
        </button>
      );
    }

    function MemeCard({ meme, onClick }) {
      const [show, setShow] = useState(false);
      return (
        <article 
          className="bg-gray-800 p-2 rounded shadow-sm overflow-hidden hover:scale-[1.01] transition-transform cursor-pointer" 
          onClick={onClick}
        >
          <div className="relative w-full h-48 bg-gray-700 rounded overflow-hidden">
            <img
              src={meme.url}
              alt={meme.title}
              className="w-full h-full object-cover"
              onLoad={() => setShow(true)}
              onError={() => setShow(true)}
            />
            {!show && <div className="absolute inset-0 flex items-center justify-center">åŠ è½½ä¸­...</div>}
          </div>
          <div className="mt-2">
            <div className="text-sm font-semibold truncate">{meme.title}</div>
            <div className="text-xs text-gray-400 flex justify-between">
              <span>{meme.source || "source"}</span>
              {meme.date && <span className="text-gray-500">{meme.date}</span>}
            </div>
          </div>
        </article>
      );
    }

    function ImageModal({ meme, onClose }) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
          <div className="relative max-w-4xl max-h-full p-4">
            <button 
              onClick={onClose} 
              className="absolute top-2 right-2 text-white text-4xl font-bold z-10 px-2 py-1 rounded hover:bg-gray-800 transition-colors"
            >
              Ã—
            </button>
            <img 
              src={meme.url} 
              alt={meme.title} 
              className="max-w-full max-h-[90vh] object-contain rounded shadow-lg"
            />
            <div className="mt-4 text-center text-white">
              <h3 className="text-lg font-semibold">{meme.title}</h3>
              <p className="text-sm text-gray-300">{meme.source || "source"}</p>
              {meme.date && <p className="text-sm text-gray-400">{meme.date}</p>}
            </div>
          </div>
        </div>
      );
    }

    function AnimePage({ onBack }) {
      const animeList = [
        {
          id: 1,
          title: "One Piece",
          poster: "https://s4.anilist.co/file/anilistcdn/media/anime/cover/large/bx118546-5W2hEc5Dyv6X.jpg",
          description: "Gol D. Roger was known as the 'Pirate King,' the strongest and most infamous being who had sailed the Grand Line. The capture and execution of Roger by the World Government brought a change throughout the world.",
          episodes: "Ongoing",
          status: "Watching"
        },
        {
          id: 2,
          title: "Attack on Titan",
          poster: "https://s4.anilist.co/file/anilistcdn/media/anime/cover/large/bx134258-9x0kV2nI5b0p.jpg",
          description: "After his hometown is destroyed and his mother is killed, young Eren Yeager vows to cleanse the earth of the giant humanoid Titans that have brought humanity to the brink of extinction.",
          episodes: "Final Season",
          status: "Watching"
        },
        {
          id: 3,
          title: "Jujutsu Kaisen",
          poster: "https://s4.anilist.co/file/anilistcdn/media/anime/cover/large/bx136461-YU4M6XzW5q2Q.jpg",
          description: "Yuji Itadori is a boy with tremendous physical strength, though he lives a completely ordinary high school life. One day, to save a classmate who has been attacked by curses, he eats the finger of Sukuna, taking the curse into his own soul.",
          episodes: "Season 2",
          status: "Watching"
        },
        {
          id: 4,
          title: "Demon Slayer",
          poster: "https://s4.anilist.co/file/anilistcdn/media/anime/cover/large/bx117344-5sH2dM4a7g0y.jpg",
          description: "It is the Taisho Period in Japan. Tanjiro, a kindhearted boy who sells charcoal for a living, finds his family slaughtered by a demon. To make matters worse, his younger sister Nezuko, the sole survivor, shows signs of demon transformation.",
          episodes: "Swordsmith Village Arc",
          status: "Watching"
        }
      ];

      return (
        <section>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              <button onClick={onBack} className="px-3 py-1 rounded bg-gray-800">è¿”å›</button>
              <div className="text-lg font-semibold">ä½œè€…åœ¨çœ‹çš„ç•ª</div>
            </div>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {animeList.map((anime) => (
              <AnimeCard key={anime.id} anime={anime} />
            ))}
          </div>
          <div className="mt-4 text-sm text-gray-500">Giu Giu çš„è¿½ç•ªåˆ—è¡¨ â€” åŸºäº MyAnimeList æ•°æ®ï¼Œçº¯é™æ€å±•ç¤ºã€‚</div>
        </section>
      );
    }

    function AnimeCard({ anime }) {
      const [show, setShow] = useState(false);
      return (
        <article className="bg-gray-800 p-2 rounded shadow-sm overflow-hidden hover:scale-[1.01] transition-transform">
          <div className="relative w-full h-48 bg-gray-700 rounded overflow-hidden">
            <img
              src={anime.poster}
              alt={anime.title}
              className="w-full h-full object-cover"
              onLoad={() => setShow(true)}
              onError={() => setShow(true)}
            />
            {!show && <div className="absolute inset-0 flex items-center justify-center">åŠ è½½ä¸­...</div>}
          </div>
          <div className="mt-2">
            <div className="text-sm font-semibold truncate">{anime.title}</div>
            <div className="text-xs text-gray-400">{anime.status}</div>
            <div className="text-xs text-gray-500 mt-1 line-clamp-2">{anime.description}</div>
            <div className="text-xs text-indigo-400 mt-1">{anime.episodes}</div>
          </div>
        </article>
      );
    }

    // -------------------------- Fetching and source logic --------------------------
    // Helpers: timeout fetch
    async function fetchWithTimeout(url, opts = {}, timeout = 8000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        clearTimeout(id);
        return res;
      } finally {
        clearTimeout(id);
      }
    }

    async function tryFetchSources(sources) {
      // sources: [{name, url, parser: async (resp)=>[] , method?, headers?, resType?}]
      for (const s of sources) {
        try {
          const res = await fetchWithTimeout(s.url, { method: s.method || "GET", headers: s.headers || {} }, s.timeout || 9000);
          if (!res.ok) throw new Error(`${s.name} status ${res.status}`);
          const data = await res[s.resType || "json"]();
          const imgs = await s.parser(data);
          if (Array.isArray(imgs) && imgs.length > 0) {
            console.info(`source ${s.name} success, got ${imgs.length}`);
            return imgs;
          }
        } catch (e) {
          console.warn(`source ${s.name} failed:`, e);
          // try next
        }
      }
      return [];
    }

    async function tryFetchForeignImages() {
      // Define multiple overseas sources with parsers (enhanced with date where possible)
      const sources = [
        // Meme API (D3vd) - simple gimme endpoint (no date available)
        {
          name: "MemeAPI_gimme",
          url: "https://meme-api.com/gimme/50",
          parser: async (d) => {
            // if gimme returns a list or single
            const arr = Array.isArray(d.memes || d) ? (d.memes || d) : (d ? [d] : []);
            const out = (arr || []).map((p, i) => ({ 
              id: p.postLink || `memeapi-${i}`, 
              title: p.title || "meme", 
              url: p.url, 
              source: p.subreddit || "meme-api",
              date: null // no date in response
            })).filter(x => x.url);
            return out;
          },
        },
        // Imgflip templates (not user memes but usable, no date)
        {
          name: "Imgflip_templates",
          url: "https://api.imgflip.com/get_memes",
          parser: async (d) => {
            const memes = d?.data?.memes || [];
            return memes.map((m) => ({ 
              id: m.id, 
              title: m.name, 
              url: m.url, 
              source: "imgflip",
              date: null
            }));
          },
        },
        // Reddit top r/memes (with date from created_utc)
        {
          name: "Reddit_r_memes",
          url: "https://www.reddit.com/r/memes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url && (url.endsWith('.jpg') || url.endsWith('.png') || url.includes('i.redd.it') || url.includes('i.imgur.com') || url.startsWith('http'))) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
        // Reddit r/dankmemes (with date)
        {
          name: "Reddit_dank",
          url: "https://www.reddit.com/r/dankmemes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
        // Placeholder static pics (picsum) as last resort (no date)
        {
          name: "picsum_fallback",
          url: "https://picsum.photos/v2/list?page=2&limit=50",
          parser: async (d) => {
            return (d || []).map((p) => ({ 
              id: `picsum-${p.id}`, 
              title: p.author || "picsum", 
              url: `https://picsum.photos/id/${p.id}/800/600`, 
              source: "picsum",
              date: null
            }));
          },
          resType: 'json'
        },
      ];
      return await tryFetchSources(sources);
    }

    async function tryFetchDomesticImages() {
      // Domestic sources â€” many public domestic endpoints don't return image URLs directly.
      // We attempt a few aggregator endpoints (may require API key or CORS proxy).
      // Enhanced with date where possible (e.g., Bilibili pubdate).
      // Fill in YOUR_API_KEY where needed or use a server-side proxy.
      const ITAPI_KEY = ""; // optional: your itapi key
      const HUMOR_API_KEY = ""; // placeholder if you have keys for other services
      const sources = [
        // Example aggregator: itapi.cn (hot topics) â€” may return text hotspots (date if available)
        {
          name: "ITAPI_hot",
          url: ITAPI_KEY ? `https://api.itapi.cn/hot?api_key=${ITAPI_KEY}` : `https://api.itapi.cn/hot`,
          parser: async (d) => {
            // We try to derive images from returned topics; if none, return an empty array
            // NOTE: real response shapes differ â€” this is a best-effort placeholder parser.
            const items = d?.data || d || [];
            const out = [];
            for (let i = 0; i < Math.min(20, items.length); i++) {
              const t = items[i];
              // If the topic has an image field
              const img = t?.pic || t?.image || (t?.thumb && t.thumb[0]);
              if (img) {
                const date = t?.date || t?.time || null; // assume string date if present
                out.push({ id: `itapi-${i}`, title: t.title || t.keyword || "çƒ­æœ", url: img, source: "itapi", date });
              }
            }
            return out;
          },
        },
        // Bç«™/å“”å“©å“”å“© è§†é¢‘çƒ­æ¦œï¼ˆusing unofficial endpoints sometimes blockedï¼‰â€” with pubdate
        {
          name: "Bilibili_hot_videos",
          url: "https://api.bilibili.com/x/web-interface/ranking?rid=0&day=3&jsonp=jsonp",
          parser: async (d) => {
            const list = d?.data?.list || [];
            return list.map((v, i) => {
              const url = v?.pic || `https://i0.hdslb.com/bfs/archive/${v?.bvid || ''}.jpg`;
              const date = v?.pubdate ? new Date(v.pubdate * 1000).toDateString() : null;
              return { id: v?.aid || `b-${i}`, title: v?.title || "bç«™", url, source: "bilibili", date };
            }).filter(x => x.url);
          },
        },
        // Weibo çƒ­æœ apiï¼ˆéå®˜æ–¹ï¼‰ç¤ºä¾‹ â€” often blocked by CORS (no images/date)
        {
          name: "Weibo_hot_example",
          url: "https://weibo.com/ajax/statuses/hot_band",
          parser: async (d) => {
            // likely won't have images â€” skip
            return [];
          },
        },
        // Fallback: use picsum (å›½å†…ä¹Ÿå¯ç”¨) and local placeholders (no date)
        {
          name: "picsum_dom_fallback",
          url: "https://picsum.photos/v2/list?page=5&limit=50",
          parser: async (d) => {
            return (d || []).map((p) => ({ 
              id: `picsum-d-${p.id}`, 
              title: p.author || "picsum", 
              url: `https://picsum.photos/id/${p.id}/800/600`, 
              source: "picsum",
              date: null
            }));
          },
        },
        // Custom user-provided JSON endpoint (you can point this to your own proxy that scrapes Chinese platforms)
        {
          name: "custom_user_json",
          url: window.__MEMEWAVE_CUSTOM_JSON_URL || "https://yourdomain.com/memes.json",
          parser: async (d) => {
            // Expect array of {title, url, date?}
            if (!Array.isArray(d)) return [];
            return d.map((it, i) => ({ 
              id: it.id || `custom-${i}`, 
              title: it.title || it.text || 'custom', 
              url: it.url, 
              source: 'custom',
              date: it.date || null
            })).filter(x => x.url);
          },
        },
      ];
      return await tryFetchSources(sources);
    }

    // Utilities
    function shuffleArray(a) {
      const arr = [...a];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Render the app
    ReactDOM.render(<MemeWaveApp />, document.getElementById('root'));
  </script>
</body>
</html>
