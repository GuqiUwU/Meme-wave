<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MemeWave - made by Giu Giu</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom styles if needed beyond Tailwind */
  </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen">
  <div id="root"></div>
  <script type="text/babel">
    // MemeWave â€” single-file React front-end (standalone HTML version)
    // Dark theme, 1 page: Feed + Anime
    // Integrates multiple overseas + domestic sources with automatic fallback & retry logic.
    // Added: Time filter (All, Today, Week, Month) â€” client-side based on meme dates where available.
    // Added: Click on feed images to view full size in modal.
    // Added: ä½œè€…åœ¨çœ‹çš„ç•ª page.
    // Added: Infinite scroll â€” load more when scroll to bottom.
    // Added: Background caching â€” preload inactive tab in background every 10s if <200 items.
    // NOTE: This is still a front-end-only demo. CORS and API keys may be required for some sources.
    // Usage: Open index.html in browser (use dev proxy for CORS if needed).
    const { useEffect, useState, useRef, useMemo, useCallback } = React;
    function MemeWaveApp() {
      const [route, setRoute] = useState("feed");
      const [foreignFeed, setForeignFeed] = useState([]);
      const [domesticFeed, setDomesticFeed] = useState([]);
      const [loading, setLoading] = useState(false);
      const [activeTab, setActiveTab] = useState("foreign");
      const [timeFilter, setTimeFilter] = useState("all");
      const [error, setError] = useState(null);
      const [selectedMeme, setSelectedMeme] = useState(null);
      const [hasMoreForeign, setHasMoreForeign] = useState(false);
      const [hasMoreDomestic, setHasMoreDomestic] = useState(false);
      const [isLoadingMore, setIsLoadingMore] = useState(false);
      const [backgroundInterval, setBackgroundInterval] = useState(null);
      useEffect(() => {
        loadFeeds();
      }, []);
      useEffect(() => {
        if (backgroundInterval) clearInterval(backgroundInterval);
        const interval = setInterval(() => {
          const inactiveTab = activeTab === "foreign" ? "domestic" : "foreign";
          const inactiveFeed = inactiveTab === "foreign" ? foreignFeed : domesticFeed;
          const inactiveHasMore = inactiveTab === "foreign" ? hasMoreForeign : hasMoreDomestic;
          if (inactiveFeed.length < 200 && inactiveHasMore && !isLoadingMore) {
            loadMoreFeed(inactiveTab);
          }
        }, 10000); // Preload inactive every 10s
        setBackgroundInterval(interval);
        return () => clearInterval(interval);
      }, [activeTab, foreignFeed.length, domesticFeed.length, hasMoreForeign, hasMoreDomestic, isLoadingMore, loadMoreFeed]);
      async function loadFeeds() {
        setLoading(true);
        setError(null);
        try {
          const fImgs = await tryFetchForeignImages();
          const dImgs = await tryFetchDomesticImages();
          setForeignFeed(shuffleArray(fImgs).slice(0, 40));
          setHasMoreForeign(fImgs.length >= 40);
          setDomesticFeed(shuffleArray(dImgs).slice(0, 40));
          setHasMoreDomestic(dImgs.length >= 40);
        } catch (e) {
          console.error(e);
          setError("åŠ è½½éƒ¨åˆ†æ¢—å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚å¯èƒ½æ˜¯ CORS æˆ–æ¥å£éœ€è¦ API Keyã€‚");
        } finally {
          setLoading(false);
        }
      }
      const loadMoreFeed = useCallback(async (tab) => {
        if (isLoadingMore) return;
        const hasMore = tab === "foreign" ? hasMoreForeign : hasMoreDomestic;
        if (!hasMore) return;
        setIsLoadingMore(true);
        try {
          let moreImgs;
          if (tab === "foreign") {
            moreImgs = await tryFetchForeignImages();
          } else {
            moreImgs = await tryFetchDomesticImages();
          }
          const currentFeedState = tab === "foreign" ? foreignFeed : domesticFeed;
          const newMemes = moreImgs.filter(m => !currentFeedState.some(c => c.id === m.id));
          const toAdd = shuffleArray(newMemes).slice(0, 20);
          const updatedFeed = [...currentFeedState, ...toAdd];
          if (tab === "foreign") {
            setForeignFeed(updatedFeed);
            setHasMoreForeign(toAdd.length > 0 || moreImgs.length >= 20);
          } else {
            setDomesticFeed(updatedFeed);
            setHasMoreDomestic(toAdd.length > 0 || moreImgs.length >= 20);
          }
        } catch (e) {
          console.error(e);
        } finally {
          setIsLoadingMore(false);
        }
      }, [foreignFeed, domesticFeed, hasMoreForeign, hasMoreDomestic, isLoadingMore]);
      const currentFeed = activeTab === "foreign" ? foreignFeed : domesticFeed;
      const filteredFeed = useMemo(() => {
        const now = new Date();
        return currentFeed.filter((m) => {
          if (timeFilter === "all" || !m.date) return true;
          const mDate = new Date(m.date);
          switch (timeFilter) {
            case "today":
              return mDate.toDateString() === now.toDateString();
            case "week":
              return mDate > new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            case "month":
              return mDate > new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            default:
              return true;
          }
        });
      }, [currentFeed, timeFilter]);
      const hasMore = activeTab === "foreign" ? hasMoreForeign : hasMoreDomestic;
      return (
        <div className="min-h-screen bg-gray-900 text-gray-100 font-sans">
          <header className="p-4 flex items-center justify-between border-b border-gray-800">
            <h1 className="text-2xl font-bold tracking-tight">MemeWave</h1>
            <nav className="flex items-center gap-2">
              <button onClick={() => setRoute("feed")} className={`px-3 py-1 rounded-md ${route === "feed" ? "bg-gray-800" : "bg-transparent"}`}>
                çƒ­æ¢—å¢™
              </button>
              <button onClick={() => setRoute("anime")} className={`px-3 py-1 rounded-md ${route === "anime" ? "bg-gray-800" : "bg-transparent"}`}>
                ä½œè€…åœ¨çœ‹çš„ç•ª
              </button>
              <button onClick={loadFeeds} className="px-3 py-1 rounded-md bg-gray-800 ml-2">åˆ·æ–°æ¢—</button>
            </nav>
          </header>
          <main className="p-6">
            {route === "feed" ? (
              <FeedPage
                loading={loading}
                error={error}
                filteredFeed={filteredFeed}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
                timeFilter={timeFilter}
                setTimeFilter={setTimeFilter}
                selectedMeme={selectedMeme}
                setSelectedMeme={setSelectedMeme}
                loadMore={loadMoreFeed}
                hasMore={hasMore}
                isLoadingMore={isLoadingMore}
              />
            ) : (
              <AnimePage onBack={() => setRoute("feed")} />
            )}
            {selectedMeme && (
              <ImageModal meme={selectedMeme} onClose={() => setSelectedMeme(null)} />
            )}
            <footer className="mt-8 text-sm text-gray-500">å‰ç«¯æ¼”ç¤º â€” å·²æ¥å…¥å¤šä¸ªæ¥æºï¼ˆè§ä»£ç æ³¨é‡Šï¼‰ã€‚è‹¥æ— æ³•æ˜¾ç¤ºå›¾ç‰‡ï¼Œé€šå¸¸æ˜¯ CORS æˆ–éœ€ API Keyã€‚å¯åœ¨æœ¬åœ°ç”¨ dev proxy è§£å†³ã€‚æ–°å¢æ—¶é—´ç­›é€‰ï¼ˆåŸºäºå¯ç”¨æ—¥æœŸå­—æ®µï¼‰åŠå›¾ç‰‡ç‚¹å‡»æŸ¥çœ‹å¤§å›¾ã€‚æ–°å¢æ— é™æ»šåŠ¨åŠ è½½åŠåå°ç¼“å­˜é¢„åŠ è½½ã€‚</footer>
          </main>
        </div>
      );
    }
    function FeedPage({ loading, error, filteredFeed, activeTab, setActiveTab, timeFilter, setTimeFilter, selectedMeme, setSelectedMeme, loadMore, hasMore, isLoadingMore }) {
      const sentinelRef = useRef(null);
      useEffect(() => {
        const observer = new IntersectionObserver(
          ([entry]) => {
            if (entry.isIntersecting && hasMore && !isLoadingMore) {
              loadMore(activeTab);
            }
          },
          { threshold: 0.1 }
        );
        if (sentinelRef.current) {
          observer.observe(sentinelRef.current);
        }
        return () => {
          if (sentinelRef.current) {
            observer.unobserve(sentinelRef.current);
          }
        };
      }, [hasMore, isLoadingMore, activeTab, loadMore]);
      return (
        <section>
          <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
            <div className="flex gap-2">
              <Tab label="æµ·å¤–" active={activeTab === "foreign"} onClick={() => setActiveTab("foreign")} />
              <Tab label="å›½å†…" active={activeTab === "domestic"} onClick={() => setActiveTab("domestic")} />
            </div>
            <div className="flex items-center gap-2">
              <label className="text-sm text-gray-400">æ—¶é—´ç­›é€‰ï¼š</label>
              <select
                value={timeFilter}
                onChange={(e) => setTimeFilter(e.target.value)}
                className="px-2 py-1 rounded bg-gray-800 text-sm"
              >
                <option value="all">å…¨éƒ¨</option>
                <option value="today">ä»Šå¤©</option>
                <option value="week">ä¸€å‘¨å†…</option>
                <option value="month">ä¸€æœˆå†…</option>
              </select>
            </div>
            <div className="text-sm text-gray-400">å¤šæ¥æºåˆå¹¶ Â· çº¯å‰ç«¯</div>
          </div>
          {loading && <div className="py-12 text-center">æŠ“æ¢—ä¸­... ğŸœ</div>}
          {error && <div className="py-4 text-red-400">{error}</div>}
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {filteredFeed.map((m) => (
              <MemeCard key={m.id} meme={m} onClick={() => setSelectedMeme(m)} />
            ))}
          </div>
          {hasMore && (
            <div ref={sentinelRef} className="h-20 flex justify-center items-center">
              {isLoadingMore ? <div className="text-gray-400">åŠ è½½æ›´å¤š...</div> : <div className="text-gray-500">~ åˆ°åº•äº† ~</div>}
            </div>
          )}
          {filteredFeed.length === 0 && !loading && (
            <div className="py-12 text-center text-gray-400">æ— åŒ¹é…ç»“æœï¼Œå°è¯•è°ƒæ•´ç­›é€‰æˆ–åˆ·æ–°ã€‚</div>
          )}
        </section>
      );
    }
    function Tab({ label, active, onClick }) {
      return (
        <button onClick={onClick} className={`px-3 py-1 rounded ${active ? "bg-indigo-600 text-white" : "bg-gray-800"}`}>
          {label}
        </button>
      );
    }
    function MemeCard({ meme, onClick }) {
      const [show, setShow] = useState(false);
      return (
        <article
          className="bg-gray-800 p-2 rounded shadow-sm overflow-hidden hover:scale-[1.01] transition-transform cursor-pointer"
          onClick={onClick}
        >
          <div className="relative w-full h-48 bg-gray-700 rounded overflow-hidden">
            <img
              src={meme.url}
              alt={meme.title}
              className="w-full h-full object-cover"
              onLoad={() => setShow(true)}
              onError={() => setShow(true)}
            />
            {!show && <div className="absolute inset-0 flex items-center justify-center">åŠ è½½ä¸­...</div>}
          </div>
          <div className="mt-2">
            <div className="text-sm font-semibold truncate">{meme.title}</div>
            <div className="text-xs text-gray-400 flex justify-between">
              <span>{meme.source || "source"}</span>
              {meme.date && <span className="text-gray-500">{meme.date}</span>}
            </div>
          </div>
        </article>
      );
    }
    function ImageModal({ meme, onClose }) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
          <div className="relative max-w-4xl max-h-full p-4">
            <button
              onClick={onClose}
              className="absolute top-2 right-2 text-white text-4xl font-bold z-10 px-2 py-1 rounded hover:bg-gray-800 transition-colors"
            >
              Ã—
            </button>
            <img
              src={meme.url}
              alt={meme.title}
              className="max-w-full max-h-[90vh] object-contain rounded shadow-lg"
            />
            <div className="mt-4 text-center text-white">
              <h3 className="text-lg font-semibold">{meme.title}</h3>
              <p className="text-sm text-gray-300">{meme.source || "source"}</p>
              {meme.date && <p className="text-sm text-gray-400">{meme.date}</p>}
            </div>
          </div>
        </div>
      );
    }
    function AnimePage({ onBack }) {
      const animeList = [
        {
          id: 1,
          title: "Onimai (ãŠå…„ã¡ã‚ƒã‚“ã¯ãŠã—ã¾ã„ï¼)",
          poster: "https://tse4.mm.bing.net/th/id/OIP.uFVmquY49ImPRvhtYB5SeQHaKb?rs=1&pid=ImgDetMain&o=7&rm=3",
          description: "å½“å®…ç”·å“¥å“¥ä¸å°å¿ƒç”¨å¯ç–‘è¯ç‰©æŠŠè‡ªå·±çš„å“¥å“¥å˜æˆäº†å¥³å­©å­åï¼Œå±•å¼€çš„çˆ†ç¬‘æ—¥å¸¸æ•…äº‹ã€‚",
          episodes: "Season 1",
          status: "Watching",
          url: "https://onimai.jp/"
        }
      ];
      return (
        <section>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-4">
              <button onClick={onBack} className="px-3 py-1 rounded bg-gray-800">è¿”å›</button>
              <div className="text-lg font-semibold">ä½œè€…åœ¨çœ‹çš„ç•ª</div>
            </div>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {animeList.map((anime) => (
              <AnimeCard key={anime.id} anime={anime} />
            ))}
          </div>
          <div className="mt-4 text-sm text-gray-500">Giu Giu çš„è¿½ç•ªåˆ—è¡¨ â€” åŸºäº MyAnimeList æ•°æ®ï¼Œçº¯é™æ€å±•ç¤ºã€‚</div>
        </section>
      );
    }
    function AnimeCard({ anime }) {
      const [show, setShow] = useState(false);
      const handleClick = () => {
        window.location.href = anime.url;
      };
      return (
        <article onClick={handleClick} className="bg-gray-800 p-2 rounded shadow-sm overflow-hidden hover:scale-[1.01] transition-transform cursor-pointer">
          <div className="relative w-full h-48 bg-gray-700 rounded overflow-hidden">
            <img
              src={anime.poster}
              alt={anime.title}
              className="w-full h-full object-cover"
              onLoad={() => setShow(true)}
              onError={() => setShow(true)}
            />
            {!show && <div className="absolute inset-0 flex items-center justify-center">åŠ è½½ä¸­...</div>}
          </div>
          <div className="mt-2">
            <div className="text-sm font-semibold truncate">{anime.title}</div>
            <div className="text-xs text-gray-400">{anime.status}</div>
            <div className="text-xs text-gray-500 mt-1 line-clamp-2">{anime.description}</div>
            <div className="text-xs text-indigo-400 mt-1">{anime.episodes}</div>
          </div>
        </article>
      );
    }
    // -------------------------- Fetching and source logic --------------------------
    // Helpers: timeout fetch
    async function fetchWithTimeout(url, opts = {}, timeout = 8000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        clearTimeout(id);
        return res;
      } finally {
        clearTimeout(id);
      }
    }
    async function tryFetchSources(sources) {
      let allImgs = [];
      for (const s of sources) {
        try {
          const res = await fetchWithTimeout(s.url, { method: s.method || "GET", headers: s.headers || {} }, s.timeout || 9000);
          if (!res.ok) throw new Error(`${s.name} status ${res.status}`);
          const data = await res[s.resType || "json"]();
          const imgs = await s.parser(data);
          if (Array.isArray(imgs) && imgs.length > 0) {
            allImgs = allImgs.concat(imgs);
            console.info(`source ${s.name} added ${imgs.length}`);
          }
        } catch (e) {
          console.warn(`source ${s.name} failed:`, e);
        }
      }
      return allImgs;
    }
    async function tryFetchForeignImages() {
      const sources = [
        {
          name: "MemeAPI_gimme",
          url: "https://meme-api.com/gimme/50",
          parser: async (d) => {
            const arr = Array.isArray(d.memes || d) ? (d.memes || d) : (d ? [d] : []);
            const out = (arr || []).map((p, i) => ({
              id: p.postLink || `memeapi-${i}`,
              title: p.title || "meme",
              url: p.url,
              source: p.subreddit || "meme-api",
              date: null
            })).filter(x => x.url);
            return out;
          },
        },
        {
          name: "Imgflip_templates",
          url: "https://api.imgflip.com/get_memes",
          parser: async (d) => {
            const memes = d?.data?.memes || [];
            return memes.map((m) => ({
              id: m.id,
              title: m.name,
              url: m.url,
              source: "imgflip",
              date: null
            }));
          },
        },
        {
          name: "Reddit_r_memes",
          url: "https://www.reddit.com/r/memes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url && (url.endsWith('.jpg') || url.endsWith('.png') || url.includes('i.redd.it') || url.includes('i.imgur.com') || url.startsWith('http'))) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
        {
          name: "Reddit_dank",
          url: "https://www.reddit.com/r/dankmemes/top.json?limit=50&t=day",
          parser: async (d) => {
            const children = d?.data?.children || [];
            const out = [];
            for (const c of children) {
              const post = c.data;
              const url = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, "&") || post.url;
              if (url) {
                const date = post.created_utc ? new Date(post.created_utc * 1000).toDateString() : null;
                out.push({ id: post.id, title: post.title, url, source: `r/${post.subreddit}`, date });
              }
            }
            return out;
          },
        },
      ];
      return await tryFetchSources(sources);
    }
    async function tryFetchDomesticImages() {
      // Domestic sources â€” using memes.tw only, with CORS proxy
      const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
      const targetUrl = 'https://memes.tw/';
      const sources = [
        {
          name: "memes.tw",
          url: CORS_PROXY + encodeURIComponent(targetUrl),
          resType: "text",
          timeout: 10000,
          parser: async (html) => {
            console.log("Parsing memes.tw HTML...");
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            // Enhanced selectors for memes.tw - trying more patterns based on common blog/meme site structures
            const memeElements = doc.querySelectorAll('img[src*="jpg"], img[src*="png"], img[data-src*="jpg"], img[data-src*="png"], .entry-content img, .post-content img, .meme-container img, article img, .wp-post-image');
            const out = [];
            let i = 0;
            for (const img of memeElements) {
              if (i >= 50) break;
              let src = img.src || img.getAttribute('data-src') || img.getAttribute('data-lazy-src') || img.getAttribute('srcset')?.split(',')[0]?.trim().split(' ')[0];
              if (!src) continue;
              // Clean up srcset if present
              if (src.includes('srcset')) src = src.split(',')[0].trim().split(' ')[0];
              if (src && (src.includes('.jpg') || src.includes('.png') || src.includes('.gif')) && !src.includes('avatar') && !src.includes('logo') && !src.includes('icon') && !src.includes('wp-includes')) {
                // Find parent for title and date
                let parent = img.closest('article, .post, .entry, .meme, .item, .card, div[class*="post"], div[class*="entry"], section') || img.parentElement;
                if (!parent) parent = img;
                let titleEl = parent.querySelector('h1, h2, h3, h4, .title, .headline, .post-title, .entry-title, p, .caption') || img;
                let title = (titleEl.textContent || titleEl.alt || titleEl.title || `Meme ${i + 1}`).trim().substring(0, 50);
                if (!title || title.length < 3) title = `æ¢—å›¾ ${i + 1}`;
                let dateEl = parent.querySelector('.date, .time, time, .published, [datetime], .post-date') || parent.querySelector('time');
                let date = dateEl ? (dateEl.textContent || dateEl.getAttribute('datetime')).trim() : null;
                if (date && !date.includes('Date')) date = new Date(date).toDateString() || date;
                // Resolve URL
                let fullUrl;
                try {
                  fullUrl = src.startsWith('http') ? src : new URL(src, targetUrl).href;
                } catch (e) {
                  console.warn("Invalid URL:", src);
                  continue;
                }
                out.push({
                  id: `memes-${i}-${Date.now()}`,
                  title,
                  url: fullUrl,
                  source: "memes.tw",
                  date
                });
                i++;
              }
            }
            console.log(`Parsed ${out.length} memes from memes.tw. Sample:`, out.slice(0, 2));
            return out.filter(x => x.url && x.url.length > 10 && !x.url.includes('data:image'));
          },
        },
      ];
      return await tryFetchSources(sources);
    }
    // Utilities
    function shuffleArray(a) {
      const arr = [...a];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    // Render the app
    ReactDOM.render(<MemeWaveApp />, document.getElementById('root'));
  </script>
</body>
</html>
